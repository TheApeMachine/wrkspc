// Code generated by capnpc-go. DO NOT EDIT.

package spd

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
)

type Datagram capnp.Struct

// Datagram_TypeID is the unique identifier for the type Datagram.
const Datagram_TypeID = 0x9b4169eff5c9b6f0

func NewDatagram(s *capnp.Segment) (Datagram, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 6})
	return Datagram(st), err
}

func NewRootDatagram(s *capnp.Segment) (Datagram, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 6})
	return Datagram(st), err
}

func ReadRootDatagram(msg *capnp.Message) (Datagram, error) {
	root, err := msg.Root()
	return Datagram(root.Struct()), err
}

func (s Datagram) String() string {
	str, _ := text.Marshal(0x9b4169eff5c9b6f0, capnp.Struct(s))
	return str
}

func (s Datagram) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Datagram) DecodeFromPtr(p capnp.Ptr) Datagram {
	return Datagram(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Datagram) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Datagram) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Datagram) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Datagram) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Datagram) Uuid() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(5)
	return []byte(p.Data()), err
}

func (s Datagram) HasUuid() bool {
	return capnp.Struct(s).HasPtr(5)
}

func (s Datagram) SetUuid(v []byte) error {
	return capnp.Struct(s).SetData(5, v)
}

func (s Datagram) Version() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Datagram) HasVersion() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Datagram) SetVersion(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

func (s Datagram) Role() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return []byte(p.Data()), err
}

func (s Datagram) HasRole() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Datagram) SetRole(v []byte) error {
	return capnp.Struct(s).SetData(1, v)
}

func (s Datagram) Scope() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return []byte(p.Data()), err
}

func (s Datagram) HasScope() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Datagram) SetScope(v []byte) error {
	return capnp.Struct(s).SetData(2, v)
}

func (s Datagram) Identity() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return []byte(p.Data()), err
}

func (s Datagram) HasIdentity() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s Datagram) SetIdentity(v []byte) error {
	return capnp.Struct(s).SetData(3, v)
}

func (s Datagram) Timestamp() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s Datagram) SetTimestamp(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s Datagram) Layers() (capnp.DataList, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return capnp.DataList(p.List()), err
}

func (s Datagram) HasLayers() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s Datagram) SetLayers(v capnp.DataList) error {
	return capnp.Struct(s).SetPtr(4, v.ToPtr())
}

// NewLayers sets the layers field to a newly
// allocated capnp.DataList, preferring placement in s's segment.
func (s Datagram) NewLayers(n int32) (capnp.DataList, error) {
	l, err := capnp.NewDataList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.DataList{}, err
	}
	err = capnp.Struct(s).SetPtr(4, l.ToPtr())
	return l, err
}

// Datagram_List is a list of Datagram.
type Datagram_List = capnp.StructList[Datagram]

// NewDatagram creates a new list of Datagram.
func NewDatagram_List(s *capnp.Segment, sz int32) (Datagram_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 6}, sz)
	return capnp.StructList[Datagram](l), err
}

// Datagram_Future is a wrapper for a Datagram promised by a client call.
type Datagram_Future struct{ *capnp.Future }

func (p Datagram_Future) Struct() (Datagram, error) {
	s, err := p.Future.Struct()
	return Datagram(s), err
}

const schema_85d3acc39d94e0f8 = "x\xda<\x8d\xbfJ#Q\x1c\x85\xcf\xb9wfR\xe5" +
	"\xcfe\xa7\\\xd8~aw\xc9\x96iv\x15+\xab\xfc" +
	"|\x83Kf\x08\x03\x99d\x98\x99\x08\xa9\xac\xacm\xec" +
	"\xc47\xb0\x10QQP\x8c\xa8` \x16A\x1f \x08" +
	"\x82\x85\xa0\x8d`7\x12!)\xbf\x8fs\xf8j\x07\xff" +
	"\x9dz\xf9\x82P\xe2\xbb^\xf1v<z\x7f\x8d\x96v" +
	" \xdf\xc8\xe2c\xba\xbd{\xb5w\xbf\x09\xd7+\x01\xe6" +
	"\xe6\xd1LJ@\xfdn\x8b\xf8UdI\xf0'\xb0\xb9" +
	"U\xed\xd4\xc6\xbf[6\xe9&\x8d\x15\x9b\xdbv)\xb5" +
	"q\x93\x94\xef\xda!\x1d\x02\xe6h\x19\x90}M9S" +
	"4\x8a>g\xf2\xf4' \x87\x9a2T4Z\xf9T" +
	"\x809\xff\x0b\xc8\x89\xa6\\+\x1aG\xfb\xd4\x80\xb9\\" +
	"\x05d\xa8)cE\xba>\x1d\xc0\x8c\xd6\x00\xb9\xd5\x94" +
	"\x07E\xe39>]\xc0L\x1a\x80\x8c5\xe5Y\xb1\xe6" +
	"\xfa\xf4\x00\xf34\xcbL5\xe5Eqc=L\xb3\xa8" +
	"\xd7e\x19\x8ae\xb0\x9a\xf6:\xe1\x1c~d\xad^\xb2" +
	"\xa0\"\x0a\xc2n\x1e\xe5\x03\x00\x0b\x97Gq\x98\xe56" +
	"\x06\x13\xbaPt\xc1\x7f\x1d;\x08\xd3\x8c\x15\xb0\xa9\xf9" +
	"\xb5\xac\x80\xd5~?\x0a\xe6\xb7\xcf\x00\x00\x00\xff\xff<" +
	"\x86O\x85"

func init() {
	schemas.Register(schema_85d3acc39d94e0f8,
		0x9b4169eff5c9b6f0)
}
