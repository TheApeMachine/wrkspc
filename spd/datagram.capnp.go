// Code generated by capnpc-go. DO NOT EDIT.

package spd

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
)

type Datagram capnp.Struct

// Datagram_TypeID is the unique identifier for the type Datagram.
const Datagram_TypeID = 0x9b4169eff5c9b6f0

func NewDatagram(s *capnp.Segment) (Datagram, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 7})
	return Datagram(st), err
}

func NewRootDatagram(s *capnp.Segment) (Datagram, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 7})
	return Datagram(st), err
}

func ReadRootDatagram(msg *capnp.Message) (Datagram, error) {
	root, err := msg.Root()
	return Datagram(root.Struct()), err
}

func (s Datagram) String() string {
	str, _ := text.Marshal(0x9b4169eff5c9b6f0, capnp.Struct(s))
	return str
}

func (s Datagram) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Datagram) DecodeFromPtr(p capnp.Ptr) Datagram {
	return Datagram(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Datagram) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Datagram) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Datagram) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Datagram) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Datagram) Uuid() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(5)
	return []byte(p.Data()), err
}

func (s Datagram) HasUuid() bool {
	return capnp.Struct(s).HasPtr(5)
}

func (s Datagram) SetUuid(v []byte) error {
	return capnp.Struct(s).SetData(5, v)
}

func (s Datagram) Version() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Datagram) HasVersion() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Datagram) SetVersion(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

func (s Datagram) Type() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(6)
	return []byte(p.Data()), err
}

func (s Datagram) HasType() bool {
	return capnp.Struct(s).HasPtr(6)
}

func (s Datagram) SetType(v []byte) error {
	return capnp.Struct(s).SetData(6, v)
}

func (s Datagram) Role() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return []byte(p.Data()), err
}

func (s Datagram) HasRole() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Datagram) SetRole(v []byte) error {
	return capnp.Struct(s).SetData(1, v)
}

func (s Datagram) Scope() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return []byte(p.Data()), err
}

func (s Datagram) HasScope() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s Datagram) SetScope(v []byte) error {
	return capnp.Struct(s).SetData(2, v)
}

func (s Datagram) Identity() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return []byte(p.Data()), err
}

func (s Datagram) HasIdentity() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s Datagram) SetIdentity(v []byte) error {
	return capnp.Struct(s).SetData(3, v)
}

func (s Datagram) Timestamp() int64 {
	return int64(capnp.Struct(s).Uint64(0))
}

func (s Datagram) SetTimestamp(v int64) {
	capnp.Struct(s).SetUint64(0, uint64(v))
}

func (s Datagram) Ptr() int32 {
	return int32(capnp.Struct(s).Uint32(8))
}

func (s Datagram) SetPtr(v int32) {
	capnp.Struct(s).SetUint32(8, uint32(v))
}

func (s Datagram) Layers() (capnp.DataList, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return capnp.DataList(p.List()), err
}

func (s Datagram) HasLayers() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s Datagram) SetLayers(v capnp.DataList) error {
	return capnp.Struct(s).SetPtr(4, v.ToPtr())
}

// NewLayers sets the layers field to a newly
// allocated capnp.DataList, preferring placement in s's segment.
func (s Datagram) NewLayers(n int32) (capnp.DataList, error) {
	l, err := capnp.NewDataList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.DataList{}, err
	}
	err = capnp.Struct(s).SetPtr(4, l.ToPtr())
	return l, err
}

// Datagram_List is a list of Datagram.
type Datagram_List = capnp.StructList[Datagram]

// NewDatagram creates a new list of Datagram.
func NewDatagram_List(s *capnp.Segment, sz int32) (Datagram_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 7}, sz)
	return capnp.StructList[Datagram](l), err
}

// Datagram_Future is a wrapper for a Datagram promised by a client call.
type Datagram_Future struct{ *capnp.Future }

func (p Datagram_Future) Struct() (Datagram, error) {
	s, err := p.Future.Struct()
	return Datagram(s), err
}

const schema_85d3acc39d94e0f8 = "x\xdaD\xcd\xbd\x8a\x13Q\x18\xc6\xf1\xe7y\xcf\x99\x99" +
	"\x15\xcc\xee\x1e\xe6\x14\x16\x8a\xab\xac \x8b\x1f\xac\xe56" +
	"~`e\x95\x93\xb9\x82Cf\x08\x03\x99d\x989\x11" +
	"RYy\x07v\xe2\x1dX\xdbZ\x88\x85\x85\xa0x\x03" +
	"be\xa1\x18\xc1@\x04ad\x02\xc6\xf2\xf9\xf1\xe7}" +
	"\x0f?\xdc\xd3\xa7\x83\xd7\x848\x1b\xc5\xdd\xea\xd5\xbb\xf5" +
	"\x8f\xf2\xfes\xb8\x94\xd2m>?{\xf1\xe6\xe5\xa7\xa7" +
	"\x88\x92\x040o\xbf\x98\x8f\x09p\xfa\xbe#nvm" +
	"\x9d\xdf\xce}\xf02i|uk\xec\xebY}\xf6\xd0" +
	"\x07?I\x1a_\x0dIw\xac4\xa9\x09\x98\xef\x0f\x00" +
	"\xf7U\xd1\xfd\x12\x1aE\xcb\x1e\x7f\x9e\x00\xee\x9b\xa2\xdb" +
	"\x08\x8d\x16K\x01\xcc\xfa\x0e\xe0V\x8a\xee\x8f\xd0D\xca" +
	"R\x01\xe6\xf7#\xc0m\x143M!cK\x0d\xa4\xe4" +
	"\x08\x18Q1;O\xa1\xd9\xd3\x96\x11\x90\x9e\xe3\x19\x90" +
	"\xe9\xde\x8f(<\x8c,c \xbd\xc4\x13 \xbb\xd0\xf3" +
	"q\x9fKl\x99\x00\xe9\x95\xad_\xec\xfdz\xef\x89X" +
	"\xee\x01\xe95^\x05\xb2\xa3\xdeoP\xf8\xe4q\xd1\xb4" +
	"\xe5|\xc6\x01\x84\x03\xf0\xa0\x99O\x8b\x7f\xe3r;\x9e" +
	"\xd7\xbb\xd5\x95y1\x0beX\x02\xd8Y(\xab\xa2\x0d" +
	"\xbe\x02kF\x10F\xe0\xdd\xa9_\x16M\xcb}p\xa8" +
	"\xb8-\xf7\xc1\x83\xc5\xa2\xccw_\xc2\xf2\xff\xdd\xa4\x0e" +
	"\x0d5\x84\x1a\xfc\x1b\x00\x00\xff\xff\xac\xa4QF"

func init() {
	schemas.Register(schema_85d3acc39d94e0f8,
		0x9b4169eff5c9b6f0)
}
